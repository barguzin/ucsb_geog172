#!/usr/bin/env python
# coding: utf-8

# <h1> <center> GEOG 172: INTERMEDIATE GEOGRAPHICAL ANALYSIS </h1>
#     <h2> <center> Evgeny Noi </h2>
#         <h3> <center> Lecture 18: Multi-scale Geographically Weighted Regression </h3>

# # Regression Modeling for Spatial Relations
# 
# 1. Spatial heterogeneity 
#     1. Fixed-effect model
#     2. Spatial regimes 
# 2. Spatial Dependence 
#     1. SLX (spatial feature engineering) 
#     2. Spatial error model
#     3. Spatial lag model 
# 3. Local Modeling Frameworks (GWR and MGWR)

# <img src="https://gistbok.ucgis.org/sites/default/files/AM34_Fig1.png">

# # (M)GWR 
# 
# * estimate location-dependent relationship between dependent and independent variables 
# * place-based analytic technique
# * GWR models borrow data from neighboring observations and weight these data according to a smooth decay function based on either a physical distance or the number of nearest neighbors (higher weight for nearby locations) 

# # (M)GWR 
# 
# * Small bandwidths denote more local processes; large bandwidths indicate regional or global processes.  
# * As long as an **optimal bandwidth** is determined in the calibration of the GWR model and some continuous smooth function of distance is used, the **specific kernel function chosen is not critical**.

# <img src="https://gistbok.ucgis.org/sites/default/files/AM34_Fig2.png" width="500px">

# <img src="https://gistbok.ucgis.org/sites/default/files/AM34_Fig3.png">

# # Selecting Optimal Bandwidth 
# 
# * Trade-off between bias and variance. 
# * As bw increases, the bias increases, because we are borrowing from locations that could have been generated by increasingly different processes 
# * As bw decreases, the local parameter estimation uncertainty rises (fewer data points)  
# * Statistical optimization: trade-off between model fit and model complexity (e.g. AIC) 

# # GWR Model Specification 
# 
# $$
# Y_i = \beta_0(u_i, v_i) + \sum_{j}\beta_j(u_i, v_i)X_{ji} + \epsilon_i
# $$
# 
# where $j$ is the number of dependent variables and $\beta$ vary across space (**surface estimation**)
# 
# * overlapping sets of points are used, classical t-tests are not appropriate, thus $\alpha$ needs to be corrected and MC appliedd
# 
# $$
# \alpha = \frac{\xi}{\frac{ENP}{p}}
# $$

# # MGWR Model Specification 
# 
# $$
# Y_i = \beta_0(u_i, v_i) + \sum_{j}\beta_{bwj}(u_i, v_i)X_{ji} + \epsilon_i
# $$
# 
# where $\beta_{bwj}$ indicates the bandwidth used for calibration of the $j$th relationship. 

# <img src="https://gistbok.ucgis.org/sites/default/files/AM34_Fig4.png">

# # (M)GWR Limitations
# 
# * More computationally intensive (if you have >500 observations might take too long on desktop computers) 
# * Limited interpretation

# In[1]:


import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt 
import seaborn as sns
import pingouin as pg
import statsmodels
import statsmodels.formula.api as smf
from pysal.model import spreg
from libpysal.weights import Queen, Rook, KNN
from esda.moran import Moran
from pysal.explore import esda


# In[2]:


db = gpd.read_file("regression_db.geojson")
print(db.shape) 
db.head()


# In[3]:


variable_names = [
    "accommodates",  # Number of people it accommodates
    "bathrooms",  # Number of bathrooms
    "bedrooms",  # Number of bedrooms
    "beds",  # Number of beds
    # Below are binary variables, 1 True, 0 False
    "rt_Private_room",  # Room type: private room
    "rt_Shared_room",  # Room type: shared room
    "pg_Condominium",  # Property group: condo
    "pg_House",  # Property group: house
    "pg_Other",  # Property group: other
    "pg_Townhouse",  # Property group: townhouse
]


# In[4]:


f,ax = plt.subplots(figsize=(5,5))
db.plot(column='log_price', ax=ax, legend=True, markersize=5, alpha=.5);
ax.set_title('AirBnb listing price in San Diego \n log(price)')


# In[5]:


# Fit OLS model
m1 = spreg.OLS(
    # Dependent variable
    db[["log_price"]].values,
    # Independent variables
    db[variable_names].values,
    # Dependent variable name
    name_y="log_price",
    # Independent variable name
    name_x=variable_names,
)


# In[6]:


print(m1.summary)


# In[7]:


db.head()


# In[8]:


#Prepare Georgia dataset inputs
g_y = db['log_price'].values.reshape((-1,1))
g_X = db[variable_names].values

# reproject to get meters 
db = db.to_crs('EPSG:32611')

u = db.geometry.centroid.x
v = db.geometry.centroid.y
g_coords = list(zip(u,v))

g_X = (g_X - g_X.mean(axis=0)) / g_X.std(axis=0)

# this rescales variables
g_y = g_y.reshape((-1,1))
g_y = (g_y - g_y.mean(axis=0)) / g_y.std(axis=0)


# In[9]:


#This might be needed to turn off the OpenMP multi-threading
# %env OMP_NUM_THREADS = 1

import multiprocessing as mp
# here is how to use parallalization (works better on local machine) 
n_proc = 4 #two processors
pool = mp.Pool(n_proc) 


# In[10]:


from mgwr.gwr import GWR, MGWR
from mgwr.sel_bw import Sel_BW

#Calibrate GWR model
gwr_selector = Sel_BW(g_coords, g_y, g_X)
gwr_bw = gwr_selector.search()
print(gwr_bw)
gwr_results = GWR(g_coords, g_y, g_X, gwr_bw).fit() #bw=384


# In[34]:


gwr_results.localR2[0:10]


# In[35]:


gwr_results.summary()


# In[37]:


# # THIS CODE TAKES TOO LONG TO RUN ON MY LAPTOP 
# #Calibrate MGWR model
# mgwr_selector = Sel_BW(g_coords, g_y, g_X, multi=True)
# mgwr_bw = mgwr_selector.search(multi_bw_min=[2])
# print(mgwr_bw)
# mgwr_results = MGWR(g_coords, g_y, g_X, mgwr_selector).fit()


# In[38]:


pool.close() # Close the pool when you finish
pool.join()


# In[42]:


# Add R2 to GeoDataframe 
db['gwr_R2'] = gwr_results.localR2

fig, ax = plt.subplots(figsize=(6, 6))
db.plot(column='gwr_R2', cmap = 'coolwarm', linewidth=0.01, scheme = 'FisherJenks', k=5, legend=True, legend_kwds={'bbox_to_anchor':(1.10, 0.96)},  ax=ax)
ax.set_title('Local R2', fontsize=12)
ax.axis("off")
#plt.savefig('myMap.png',dpi=150, bbox_inches='tight')
plt.show()


# In[44]:


#Add GWR parameters to GeoDataframe
db['gwr_intercept'] = gwr_results.params[:,0]
db['gwr_accom'] = gwr_results.params[:,1]
db['gwr_bathroom'] = gwr_results.params[:,2]
db['gwr_beddroom'] = gwr_results.params[:,3]

#Obtain t-vals filtered based on multiple testing correction
gwr_filtered_t = gwr_results.filter_tvals()


# In[49]:


f, ax = plt.subplots()

db.plot('gwr_accom',ax=ax, cmap='coolwarm', legend=True);

ax.set_title('Coefficients for Accommodation');


# # Questions? 
# 
# ## Thank you for taking this class! 
# 
# ### It was different from previous years, hopefully it has gotten you started on coding and programmatic spatial analysis! 
